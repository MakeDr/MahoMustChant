// SlimeNode.compute - Phase 4: Neighbor Interactions

#pragma kernel CSMain

#define PI 3.14159265359f
#define EPSILON 0.0001f // Small value for safe float comparisons and division checks

// --- Uniform Variables (Set from C# SlimeInstance) ---
float deltaTime; // Time step for integration (Time.fixedDeltaTime)
float stiffness; // Spring constant: Node towards target circle position
float damping; // Velocity damping factor (0.8 to < 1.0)
float centerRadius; // Ideal radius of the node circle around the core
float neighborStiffness; // <<< Stiffness for springs between adjacent nodes
uint nodeCount; // Total number of simulation nodes (set by SetInt)
// --- Uniforms Not Used in Phase 4 (Keep commented or remove if preferred) ---
// float maxRadialDistance;
// float minAngleRad;
// float maxAngleRad;
// float angleConstraintStiffness;
// float collisionPushForce;
// float coreColliderRadius;

// --- Structure Definition (Must match C# exactly, including padding) ---
struct SlimeNode
{
    float2 position; // Current 2D position
    float2 velocity; // Current 2D velocity
    float mass; // Mass of the node
    // Padding to match C# struct size (likely 32 bytes total)
    float padding1;
    float padding2;
    float padding3;
};

// Core Data Structure (Must match C# CoreBufferData struct)
struct CoreBufferData
{
    float4 posRotFlags; // xy: position, z: rotation(rad), w: collisionFlags (packed uint as float)
    float4 normalMana; // xy: relevantCollisionNormal, z: mana, w: unused/padding
};

// --- Input Buffers (Read-Only for this dispatch) ---
StructuredBuffer<SlimeNode> _NodeBufferRead; // Node data from the *previous* simulation step
StructuredBuffer<CoreBufferData> _CoreBuffer; // Core's state (position, rotation, collision info)

// --- Output Buffer (Write-Only for this dispatch) ---
RWStructuredBuffer<SlimeNode> _NodeBufferWrite; // Stores the *results* of this simulation step

//-------------------------------------------------------------------------------------
// Helper Function Implementations Needed for Phase 4
//-------------------------------------------------------------------------------------

// Calculates the target position for a node on the ideal circle around the core
float2 CalculateTargetPosition(float2 corePos, float coreRot, float radius, uint index, uint count)
{
    float safeCount = max(1.0f, (float) count); // Prevent division by zero if count is 0
    float baseAngle = (2.0f * PI * (float) index / safeCount); // Calculate base angle based on index
    float currentAngle = baseAngle + coreRot; // Add core's current rotation
    float2 direction = float2(cos(currentAngle), sin(currentAngle)); // Unit vector from core
    float2 targetPos = corePos + direction * radius; // Calculate position on the circle
    return targetPos;
}

// Calculates spring force towards a target position based on Hooke's Law (F = -k * x)
float2 CalculateSpringForce(float2 currentPos, float2 targetPos, float k)
{
    float2 displacement = currentPos - targetPos; // Vector from target to current position
    float2 force = -displacement * k; // Force pulls current position towards target
    return force;
}

// Calculates spring force between two connected nodes (A and B) acting on node A
// Aims to maintain a specific restLength between them
float2 CalculateNeighborSpringForce(float2 posA, float2 posB, float restLength, float k)
{
    float2 dir = posB - posA; // Vector pointing from A to B
    float distSqr = dot(dir, dir); // Squared distance (cheaper to calculate initially)

    // Avoid calculation if nodes are practically at the same position
    if (distSqr < EPSILON * EPSILON)
        return float2(0.0f, 0.0f);

    float dist = sqrt(distSqr); // Calculate actual distance
    float displacement = dist - restLength; // Difference from desired rest length
    // Force = stiffness * displacement * direction (normalized)
    float2 force = (dir / dist) * displacement * k; // Apply force along the line connecting A and B
    return force; // This force should be applied to node A
}

// --- UNUSED HELPER FUNCTIONS (Commented Out for Phase 4) ---
/*
float AngleBetweenVectors(...) { ... }
float2 CalculateAngleConstraintForce(...) { ... }
*/

//-------------------------------------------------------------------------------------
// Main Compute Shader Kernel
//-------------------------------------------------------------------------------------
[numthreads(64, 1, 1)] // Defines the number of threads per group
void CSMain(uint3 id : SV_DispatchThreadID) // id.x is the unique index for this thread/node
{
    uint nodeIndex = id.x;

    // Bounds check: Ensure the thread index is within the valid range of nodes
    if (nodeIndex >= nodeCount)
        return;

    // --- Load Data ---
    SlimeNode currentNode = _NodeBufferRead[nodeIndex]; // Read previous state
    float2 currentPos = currentNode.position;
    float2 currentVel = currentNode.velocity;
    float mass = currentNode.mass;
    // Ensure mass is valid
    if (mass <= EPSILON)
        mass = 1.0f;

    // Load core data (position and rotation are needed)
    CoreBufferData coreData = _CoreBuffer[0];
    float2 corePos = coreData.posRotFlags.xy;
    float coreRotation = coreData.posRotFlags.z;
    // Collision info is loaded but not used in Phase 4

    // --- Calculate Ideal Neighbor Distance (Rest Length) ---
    // Approximate distance nodes should be apart if perfectly arranged on the circle
    float safeCount = max(1.0f, (float) nodeCount);
    float restLength = (2.0f * PI * centerRadius) / safeCount; // Arc length approximation

    // --- Calculate Forces ---
    // 1. Calculate force towards the target position
    float2 targetPos = CalculateTargetPosition(corePos, coreRotation, centerRadius, nodeIndex, nodeCount);
    float2 forceToTarget = CalculateSpringForce(currentPos, targetPos, stiffness);

    // 2. Calculate forces from Neighbors
    float2 forceFromNeighbors = float2(0, 0); // Initialize neighbor force
    if (nodeCount > 1) // Need at least 2 nodes for neighbors
    {
        // Calculate indices of previous and next nodes with wrap-around
        uint prevIndex = (nodeIndex + nodeCount - 1) % nodeCount;
        uint nextIndex = (nodeIndex + 1) % nodeCount;

        // Read neighbor positions from the Read buffer (Crucial for double buffering)
        float2 prevPos = _NodeBufferRead[prevIndex].position;
        float2 nextPos = _NodeBufferRead[nextIndex].position;

        // Calculate spring force from the previous neighbor
        forceFromNeighbors += CalculateNeighborSpringForce(currentPos, prevPos, restLength, neighborStiffness); // Use neighborStiffness
        // Calculate spring force from the next neighbor
        forceFromNeighbors += CalculateNeighborSpringForce(currentPos, nextPos, restLength, neighborStiffness); // Use neighborStiffness
    }

    // --- Sum Forces ---
    // Combine the force pulling towards the target and forces from neighbors
    float2 totalForce = forceToTarget + forceFromNeighbors; // Added neighbor force

    // --- Physics Integration (Simple Euler Integration) ---
    // Calculate acceleration: a = F / m
    float2 acceleration = totalForce / mass;
    // Update velocity: v = v + a * dt
    currentVel += acceleration * deltaTime;
    // Apply damping to velocity: v = v * dampingFactor
    currentVel *= damping;
    // Predict next position: p_predicted = p + v * dt
    float2 predictedPos = currentPos + currentVel * deltaTime;

    // --- NO CONSTRAINTS APPLIED IN PHASE 4 YET ---
    // Radial distance, angle constraints, core collision response will be added later.

    // --- Final Position Update ---
    // In this phase, the predicted position is the final position
    currentPos = predictedPos;

    // --- Store Results ---
    // Prepare the output structure with updated values
    SlimeNode outputNode;
    outputNode.position = currentPos;
    outputNode.velocity = currentVel; // Store the updated velocity
    outputNode.mass = mass;
    // Initialize padding fields explicitly (best practice for safety)
    outputNode.padding1 = 0.0f;
    outputNode.padding2 = 0.0f;
    outputNode.padding3 = 0.0f;

    // Write the final state to the output buffer for the next frame's read pass
    _NodeBufferWrite[nodeIndex] = outputNode;
}