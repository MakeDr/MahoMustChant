#pragma kernel CSMain

#define PI 3.14159265359f

// Uniform variables
float deltaTime;
float stiffness; // Stiffness for attraction to the core target position
float damping;
float centerRadius;
float neighborStiffness; // Stiffness for springs between adjacent nodes
uint nodeCount;

// Structure definition for each slime node
struct SlimeNode
{
    float2 position;
    float2 velocity;
    // float2 force; // Removed, calculated transiently
    float mass;
};

// Input Buffer (Read-Only for this dispatch)
// Contains node states from the *previous* frame
StructuredBuffer<SlimeNode> _NodeBufferRead;

// Input Buffer for Core (Read-Only)
StructuredBuffer<float4> _CoreBuffer; // x: pos.x, y: pos.y, z: rotation, w: mana

// Output Buffer (Write-Only for this dispatch)
// Stores the newly calculated node states for the *current* frame
RWStructuredBuffer<SlimeNode> _NodeBufferWrite;

// Helper function to calculate the target position for a node
float2 CalculateTargetPosition(float2 corePos, float coreRot, float radius, uint index, uint count)
{
    float baseAngle = (2.0f * PI * (float) index / (float) count);
    float currentAngle = baseAngle + coreRot;
    float2 direction = float2(cos(currentAngle), sin(currentAngle));
    float2 targetPos = corePos + direction * radius;
    return targetPos;
}

// Helper function to calculate the spring force towards the target position
float2 CalculateSpringForce(float2 currentPos, float2 targetPos, float k)
{
    float2 displacement = currentPos - targetPos;
    float2 force = -displacement * k;
    return force;
}

// Helper function to calculate spring force between two connected nodes
float2 CalculateNeighborSpringForce(float2 posA, float2 posB, float restLength, float k)
{
    float2 dir = posB - posA; // Vector from A to B
    float dist = length(dir);

    // Avoid division by zero if nodes are at the same position
    if (dist < 0.0001f)
    {
        return float2(0.0f, 0.0f);
    }

    float displacement = dist - restLength; // How much the spring is stretched (+) or compressed (-)
    float2 force = normalize(dir) * displacement * k; // Force magnitude and direction

    // This force acts on node A, pulling it towards B if stretched, pushing away if compressed.
    return force;
}


[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint nodeIndex = id.x;
    if (nodeIndex >= nodeCount)
        return;

    // --- Calculate Ideal Neighbor Distance (Rest Length) ---
    // Circumference = 2 * PI * R
    // Distance between nodes = Circumference / nodeCount
    float restLength = (2.0f * PI * centerRadius) / (float) nodeCount;

    // --- Load Data (READ from _NodeBufferRead) ---
    // Load the current node's state from the *read* buffer
    SlimeNode currentNode = _NodeBufferRead[nodeIndex];
    float2 currentPos = currentNode.position;
    float2 currentVel = currentNode.velocity;
    float mass = currentNode.mass;
    if (mass <= 0.0f)
        mass = 1.0f; // Ensure valid mass

    // Load core data
    float4 coreData = _CoreBuffer[0];
    float2 corePos = coreData.xy;
    float coreRotation = coreData.z;

    // --- Calculate Forces ---
    // 1. Force towards the individual target position on the circle
    float2 targetPos = CalculateTargetPosition(corePos, coreRotation, centerRadius, nodeIndex, nodeCount);
    float2 forceToTarget = CalculateSpringForce(currentPos, targetPos, stiffness);

    // 2. Forces from neighbors
    float2 forceFromNeighbors = float2(0.0f, 0.0f);

    // --- Calculate Neighbor Indices with Wrap-Around ---
    // Using modulo (%) handles wrap-around cleanly
    // Note: HLSL % operator can return negative for negative inputs,
    // so adding nodeCount ensures a positive result before the final modulo.
    uint prevIndex = (nodeIndex + nodeCount - 1) % nodeCount;
    uint nextIndex = (nodeIndex + 1) % nodeCount;

    // --- Load Neighbor Data (READ from _NodeBufferRead) ---
    // IMPORTANT: Read neighbor positions also from the READ buffer to avoid race conditions!
    float2 prevPos = _NodeBufferRead[prevIndex].position;
    float2 nextPos = _NodeBufferRead[nextIndex].position;

    // --- Calculate Neighbor Forces ---
    // Force pulling/pushing current node towards/away from previous node
    forceFromNeighbors += CalculateNeighborSpringForce(currentPos, prevPos, restLength, neighborStiffness);
    // Force pulling/pushing current node towards/away from next node
    forceFromNeighbors += CalculateNeighborSpringForce(currentPos, nextPos, restLength, neighborStiffness);

    // --- Sum Forces ---
    float2 totalForce = forceToTarget + forceFromNeighbors;

    // --- Physics Integration (Euler) ---
    float2 acceleration = totalForce / mass;
    currentVel += acceleration * deltaTime;
    currentVel *= damping;
    currentPos += currentVel * deltaTime;

    // --- Store Results (WRITE to _NodeBufferWrite) ---
    // Create the output node structure
    SlimeNode outputNode;
    outputNode.position = currentPos;
    outputNode.velocity = currentVel;
    outputNode.mass = mass; // Keep mass the same (or update if needed)

    // Write the updated state to the *write* buffer
    _NodeBufferWrite[nodeIndex] = outputNode;
}